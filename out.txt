## Directory Tree

```
/
    ├── repo_to_llm/
    │   ├── __init__.py
    │   ├── core.py
    │   └── utils.py
    ├── test/
    │   ├── __init__.py
    │   └── test_core.py
    ├── LICENSE
    ├── README.md
    └── pyproject.toml
```


## File Contents

### LICENSE

```text
MIT License

Copyright (c) 2025 Luca Bottero

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

### README.md

```markdown
# repo-to-llm

CLI tool to convert a code repository into LLM-friendly markdown.

## Installation

```bash
pip install repo-to-llm
````

## Usage

```bash
repo-to-llm /path/to/your/repo > output.md
```

## Contributing

Contributions are welcome. Please open issues or pull requests on GitHub.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
```

### pyproject.toml

```text
[project]
name = "repo-to-llm"
version = "0.1.0"
description = "CLI tool to convert a code repository into LLM-friendly markdown"
readme = "README.md"
requires-python = ">=3.8"
license = { file = "LICENSE" }
authors = [{ name = "Luca Bottero", email = "lucabottero99@gmail.com" }]
keywords = ["cli", "llm", "markdown", "codebase"]
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
dependencies = [
    "gitignore-parser",
]

[project.urls]
"Homepage" = "https://github.com/luca-bottero/repo-to-llm"
"Repository" = "https://github.com/luca-bottero/repo-to-llm"
"Bug Tracker" = "https://github.com/luca-bottero/repo-to-llm/issues"

[project.scripts]
repo-to-llm = "repo_to_llm.cli:main"

[build-system]
requires = ["setuptools>=42", "wheel"]
build-backend = "setuptools.build_meta"
```

### repo_to_llm/__init__.py

```python

```

### repo_to_llm/core.py

```python
import os
import fnmatch
from pathlib import Path
import logging
from gitignore_parser import parse_gitignore

DEFAULT_MAX_BYTES = 500_000
EXCLUDED_PATTERNS = [
    ".git/*",
    ".*",
    "*.log",
    "*.log.*",
    "*.ipynb",
]

logger = logging.getLogger("repo-to-llm")

def is_text_file(path: Path, blocksize: int = 512) -> bool:
    try:
        with open(path, 'rb') as f:
            block = f.read(blocksize)
        if b'\0' in block:
            return False
        return True
    except Exception as e:
        logger.debug(f"Error reading {path}: {e}")
        return False


def should_exclude(path: Path, input_dir: Path, ignore_matcher, script_path: Path, max_bytes: int, exclude_patterns: set | None = None) -> bool:
    if path.resolve() == script_path.resolve():
        return True

    relative_str = str(path.relative_to(input_dir))

    if ignore_matcher(str(path)):
        return True

    for pattern in EXCLUDED_PATTERNS:
        if fnmatch.fnmatch(relative_str, pattern):
            return True

    if exclude_patterns:
        relative_str = str(path.relative_to(input_dir))
        for pattern in exclude_patterns:
            if fnmatch.fnmatch(relative_str, pattern):
                logger.debug(f"Excluding {relative_str} due to user pattern: {pattern}")
                return True

    if path.stat().st_size > max_bytes:
        logger.debug(f"Skipping {path} due to size > {max_bytes} bytes")
        return True

    if not is_text_file(path):
        logger.debug(f"Skipping {path} due to binary type")
        return True

    return False


def collect_files(input_dir: Path, ignore_matcher, script_path: Path, max_bytes: int, exclude_patterns: set | None = None) -> list:
    files = []
    for path in input_dir.rglob('*'):
        try:
            if path.is_file() and not should_exclude(path, input_dir, ignore_matcher, script_path, max_bytes, exclude_patterns):
                files.append(path)
        except Exception as e:
            logger.warning(f"Error processing {path}: {e}")
    return files

def generate_tree(input_dir: Path, ignore_matcher, script_path: Path, max_bytes: int, exclude_patterns: set | None = None) -> str:
    output = []

    def walk_dir(path: Path, prefix: str = '', is_last: bool = True):
        # Print the directory name
        connector = '└── ' if is_last else '├── '
        if prefix == '':
            output.append(f"{path.name}/")
        else:
            output.append(f"{prefix}{connector}{path.name}/")

        # List and filter directories
        try:
            entries = [e for e in path.iterdir() if not e.name.startswith('.') and not ignore_matcher(str(e))]
        except Exception as e:
            # Can't list directory contents
            output.append(f"{prefix}    [Error reading directory: {e}]")
            return

        dirs = sorted([e for e in entries if e.is_dir()])
        files = sorted([e for e in entries if e.is_file() and not should_exclude(e, input_dir, ignore_matcher, script_path, max_bytes, exclude_patterns)])

        total_entries = len(dirs) + len(files)

        for i, d in enumerate(dirs):
            last = (i == total_entries - 1) if len(files) == 0 else False
            # For prefix, add '│   ' if not last directory, else '    '
            new_prefix = prefix + ('    ' if is_last else '│   ')
            walk_dir(d, new_prefix, last)

        for i, f in enumerate(files):
            last = (i == len(files) - 1)
            connector = '└── ' if last else '├── '
            new_prefix = prefix + ('    ' if is_last else '│   ')
            output.append(f"{new_prefix}{connector}{f.name}")

    walk_dir(input_dir)

    return '\n'.join(output)


def guess_language(path: Path) -> str:
    ext = path.suffix.lower()
    mapping = {
        '.py': 'python',
        '.js': 'javascript',
        '.ts': 'typescript',
        '.java': 'java',
        '.cpp': 'cpp',
        '.c': 'c',
        '.html': 'html',
        '.css': 'css',
        '.json': 'json',
        '.md': 'markdown',
        '.sh': 'bash',
        '.yml': 'yaml',
        '.yaml': 'yaml',
        '.txt': 'text'
    }
    return mapping.get(ext, 'text')

def generate_report(
    input_dir: Path,
    script_path: Path,
    max_bytes: int,
    exclude_tree: bool = False,
    exclude_patterns: set | None = None
) -> str:
    gitignore_path = input_dir / '.gitignore'
    ignore_matcher = parse_gitignore(gitignore_path) if gitignore_path.exists() else lambda path: False

    output = []

    if not exclude_tree:
        output.append("## Directory Tree\n")
        output.append("```")
        output.append(generate_tree(input_dir, ignore_matcher, script_path, max_bytes, exclude_patterns))
        output.append("```\n\n")

    output.append("## File Contents\n")
    files = collect_files(input_dir, ignore_matcher, script_path, max_bytes, exclude_patterns)

    for file in sorted(files):
        rel_path = file.relative_to(input_dir)
        lang = guess_language(file)
        output.append(f"### {rel_path}\n")
        output.append(f"```{lang}")
        try:
            content = file.read_text(encoding='utf-8')
        except Exception as e:
            content = f"[Error reading file: {e}]"
        output.append(content.rstrip())
        output.append("```")
        output.append("")

    return '\n'.join(output)
```

### repo_to_llm/utils.py

```python
import argparse
import re

def parse_size(size_str: str) -> int:
    """Parse size strings like '300kb', '2mb' into bytes."""
    size_str = size_str.strip().lower()
    match = re.match(r'^(\d+(?:\.\d+)?)([kmgt]?b)?$', size_str)
    if not match:
        raise argparse.ArgumentTypeError(f"Invalid size format: {size_str}")
    number, unit = match.groups()
    number = float(number)
    unit_multipliers = {
        None: 1,
        'b': 1,
        'kb': 10**3,
        'mb': 10**6,
        'gb': 10**9,
        'tb': 10**12,
    }
    multiplier = unit_multipliers.get(unit, None)
    if multiplier is None:
        raise argparse.ArgumentTypeError(f"Unknown size unit: {unit}")
    return int(number * multiplier)
```

### test/__init__.py

```python

```

### test/test_core.py

```python
import os
import stat
import tempfile
import pytest
from pathlib import Path
from unittest.mock import patch

import repo_to_llm.core as core

@pytest.fixture
def temp_repo(tmp_path):
    # Setup a sample repo structure
    (tmp_path / ".gitignore").write_text("ignored_dir/\nignored_file.log\n")
    (tmp_path / "file1.py").write_text("print('hello')")
    (tmp_path / "file2.log").write_text("log contents")
    ignored_dir = tmp_path / "ignored_dir"
    ignored_dir.mkdir()
    (ignored_dir / "file3.py").write_text("print('ignore me')")
    binary_file = tmp_path / "binary.bin"
    binary_file.write_bytes(b"\x00\x01\x02\x03\x00")  # Contains null byte, treated as binary
    large_file = tmp_path / "large.txt"
    large_file.write_text("a" * (core.DEFAULT_MAX_BYTES + 1))
    yield tmp_path


def test_is_text_file(tmp_path):
    text_file = tmp_path / "text.txt"
    text_file.write_text("normal text")
    binary_file = tmp_path / "binary.bin"
    binary_file.write_bytes(b"\x00\x01\x02\x00")

    assert core.is_text_file(text_file) is True
    assert core.is_text_file(binary_file) is False

def test_should_exclude(temp_repo):
    ignore_matcher = core.parse_gitignore(temp_repo / ".gitignore")
    script_path = Path("/some/script/path.py")  # assume unrelated script path
    max_bytes = core.DEFAULT_MAX_BYTES

    # Exclude script file itself
    assert core.should_exclude(script_path, temp_repo, ignore_matcher, script_path, max_bytes)

    # Exclude files matched by gitignore
    ignored_file = temp_repo / "ignored_file.log"
    assert core.should_exclude(ignored_file, temp_repo, ignore_matcher, script_path, max_bytes)

    # Exclude files matched by EXCLUDED_PATTERNS (e.g. *.log)
    log_file = temp_repo / "file2.log"
    assert core.should_exclude(log_file, temp_repo, ignore_matcher, script_path, max_bytes)

    # Exclude large files
    large_file = temp_repo / "large.txt"
    assert core.should_exclude(large_file, temp_repo, ignore_matcher, script_path, max_bytes)

    # Exclude binary files
    binary_file = temp_repo / "binary.bin"
    assert core.should_exclude(binary_file, temp_repo, ignore_matcher, script_path, max_bytes)

    # Include normal python file
    py_file = temp_repo / "file1.py"
    assert not core.should_exclude(py_file, temp_repo, ignore_matcher, script_path, max_bytes)

def test_collect_files(temp_repo):
    ignore_matcher = core.parse_gitignore(temp_repo / ".gitignore")
    script_path = Path("/unrelated/script.py")
    max_bytes = core.DEFAULT_MAX_BYTES

    files = core.collect_files(temp_repo, ignore_matcher, script_path, max_bytes)
    # Should include file1.py, exclude others per should_exclude
    rel_paths = [f.relative_to(temp_repo) for f in files]
    assert Path("file1.py") in rel_paths
    assert Path("file2.log") not in rel_paths
    assert Path("ignored_dir/file3.py") not in rel_paths

def test_generate_tree(temp_repo):
    ignore_matcher = core.parse_gitignore(temp_repo / ".gitignore")
    script_path = Path("/unrelated/script.py")  # dummy path for exclusion check
    max_bytes = core.DEFAULT_MAX_BYTES
    tree_str = core.generate_tree(temp_repo, ignore_matcher, script_path, max_bytes)

    # Should include top-level files except ignored ones
    assert "file1.py" in tree_str
    assert "file2.log" not in tree_str  # ignored by pattern
    assert "ignored_dir" not in tree_str  # ignored directory
    # Directory names end with /
    assert f"{temp_repo.name}/" in tree_str or "./" in tree_str

def test_guess_language():
    assert core.guess_language(Path("foo.py")) == "python"
    assert core.guess_language(Path("bar.ts")) == "typescript"
    assert core.guess_language(Path("README.md")) == "markdown"
    assert core.guess_language(Path("unknown.ext")) == "text"
    assert core.guess_language(Path("script.sh")) == "bash"

def test_generate_report(temp_repo, monkeypatch):
    monkeypatch.setattr(core, "parse_gitignore", lambda p: lambda path: "ignored_file.log" in path)
    script_path = Path("/some/script.py")

    # Create the error-triggering file
    error_file = temp_repo / "error.py"
    error_file.write_text("some content")

    # Save the original unpatched method
    original_read_text = Path.read_text

    def mock_read_text(self, *args, **kwargs):
        if self.name == "error.py":
            raise IOError("Mocked read error")
        return original_read_text(self, *args, **kwargs)

    with patch("pathlib.Path.read_text", new=mock_read_text):
        report = core.generate_report(temp_repo, script_path, core.DEFAULT_MAX_BYTES)

        assert "## Directory Tree" in report
        assert "## File Contents" in report
        assert "file1.py" in report
        assert "print('hello')" in report  # This now works as expected
        assert "error.py" in report
        assert "[Error reading file: Mocked read error]" in report
```
